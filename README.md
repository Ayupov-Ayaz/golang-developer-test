# Тестовое задание для GoLang разработчика

## Описание задания

Необходимо реализовать сервис, который предоставляет HTTP API для загрузки 
файлов с конфиграциями и расчета результата на основе этих конфигураций.

> Формат концигураций выбирается разработчиком.

Имеется три типа конфигураций, которые загружаются в сервис:

1) Конфигурация с описанием игрового поля. Представляет собой матрицу 5x3, 
которая заполнена символами от `A` до `G` (7 символов). Пример:
```
A B C D E
F G A B C
D E F G A
```
2) Конфигурация с описанием игровых линий. Представляет собой матрицу в которой 
5 столбцов и минимум 3 строки, где каждая строка представляет описание линии. 
Линия описывается пятью числами, каждое из которых может принимать значение 
позиции из матрицы первой конфигурации, причем числа в линии не должны браться 
из одного столбца матрицы. Пример:
```
0   1   2   3   4
0   6   12  8   4
10  6   7   8   14
```
3) Конфигурация с описанием выигрышных комбинаций. Представляет собой матрицу
5x7 в которой каждая строка описывает выигрыш для комбинации по каждому символу. 
Пример:
```
A   0   0   2   4   8
B   0   0   5   10  15
C   0   0   20  50  100
D   0   0   5   10  15
E   0   0   2   4   8
F   0   0   20  50  100
G   0   0   5   10  15
```

На основе загруженных конфигураций сервис должен реализовывать расчет результата 
по следующему алгоритму:

* Проиводим обход всех линий из второй конфигурации;
* Для каждой линии выбираем символы из первой конфигурации по позициям из линии;
* Проверяем сколько повторов у символа в линии, который находится на первой 
позиции в этой линии;
* Находим в третьей конфигурации выигрыш для символа и количества повторов. Если 
у нас на первой позиции в линии символ `A` и он идет с лева на право подряд три 
раза то мы берем значение третьего столбца и первой строки из третьей 
конфигурации;
* Складываем все выигрыши для всех линий.

## Описание необходимого функционала

Сервис должен реализовывать следующий функционал:

* Загрузка конфигураций в сервис по HTTP протоколу. При загрузке конфигурации 
должны указываться тип конфигурации и имя конфигурации;
* Обслуживание HTTP запроса на расчет результата на основе загруженных 
конфигураций. В запросе должны указываться имена конфигураций, которые 
необходимо использовать для расчета результата. Ответ должен содержать 
результат выигрыша по каждой линии и общий результат.
* Обслуживание HTTP запросов к /metrics в формате prometheus.

> Методы HTTP API должны возвращать ответ в формате `json`.

Метрические данные должны включать в себя как минимум следующие метрики:

* Общее количество обработанных запросов к API-endpoints;
* Количество ошибок обработки HTTP запросов к API-endpoints;
* Данные по времени обработки HTTP запросов к API-endpoint;

## Требования к реализации
 
* Все функции _(экспортируемые и не экспортируемые)_ должны сопровождаться 
понятным комментарием;
* Не стоит излишне сокращать имена переменных и констант - код пишется для людей, 
и он должен быть максимально простым и понятным;
* Можно использовать любые сторонние пакеты, но не использовать какой-либо фреймворк;
* Весь ключевой функционал должен быть зафиксирован unit-тестами;
* После завершения работы над заданием необходимо написать сопроводительную 
документацию по работе с приложением в файле `README.md` в корне репозитория;

## Плюсами будут являться

- Настройка CI _(силами GitHub actions)_ выполняющая запуск тестов и сборки 
на каждый коммит;
- Автоматическая сборка Docker-образа с приложением;
- Интуитивно-понятное разбитие коммитов - одной конкретной задаче - один 
коммит или PR (её правки - отдельный коммит или PR);

## Результат выполнения

Ссылку на репозиторий с вашей реализацией необходимо отправить нашему 
HR или TeamLead, от которого вы получили ссылку на данный репозиторий.

Приложение должно успешно запускаться после выполнения:

```bash
$ git clone ...
$ make build
```

> Если для запуска приложения потребуется другой набор команд - обязательно 
> отразите это в файле `README.md` вашего репозитория.

Так же должны выполняться unit-тесты с помощью команды:

```bash
$ make test
# and optionally:
$ make cover
```

## От автора
* Если вы в чем-то сомневаетесь или не поняли, пожалуйста напишите на почту 
указанной ниже.
* Если вы нашли ошибку, пожалуйста напишите на почту указанной ниже (быть может 
это не ошибка, а просто вы не правильно поняли задание)
* Какие-то уточняющие вопросы по реализации можно задавать на почту 
ayaz.ayupov@releaseband.com
